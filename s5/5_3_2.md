## 5.3.2 無限メモリーの幻想の維持

* 新しい対を作るのと同じ速度でゴミ回収できれば、無限にメモリがあるように見える
* レジスタにあるポインタから car, cdr を続けて到達可能なオブジェクトが将来の計算に影響しうる
  * それ以外はゴミとして捨てる

## ストップアンドコピー

* 作業メモリーと自由メモリーに分け、cons が対を生成するときに作業メモリーに割り当てる
  * 作業メモリーが満杯になった時に有用な対を探し、自由メモリーにコピーしていく
  * コンパクションも行える

* 作業メモリーには the-cars, the-cdrs というレジスタにあるベクターがある
* 自由メモリーには new-cars, new-cdrs がある

* GC は free が指すポインタがメモリの最大サイズを超えた時に行われる
* コピーされたオブジェクトにはコピー済みのマークをつける
  * car の場所にすでに移動したオブジェクトであることのタグを置く
  * タグ付けされたオブジェクトは失恋対（broken heart）という
  * cdr には移転先アドレスを置く


* scan ポインタは走査しているところころのポインタ
  * 最終的には free とおなじになる

* relocate-old-result-in-new
  * オブジェクト移動の基本ステップを表す
  * 引数・移動すべきオブジェクトへのポインタを old という名のレジスタからとる
  * オブジェクトを移動し、移動したオブジェクトへのポインタを new というレジスタにおき、レジスタ relocate-continue に格納された入り口へ分岐して戻る

* begin-garbage-collection
  * free, scan を初期化し、relocate-old-result-in-new を起動する

* gc-loop
  * ごみあつめ主ループ
  * 捜査すべきオブジェクトがまだあるか決めないといけない
    * scan ポインタが free ポインタと一致しているかテスト
    * 一緒ならすべてのアクセス可能なオブジェクトは移されている
    * 中断した計算を再実行できるようにする gc-flip へ行く
  * まだ操作すべき対があれば次の car を移すため、移動のためのルーチンに入る

* update-car
  * scan に new のポインタをセット
  * old に scan の位置をセット
